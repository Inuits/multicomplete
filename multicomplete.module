<?php

/* global todo list 
 * 
 * support for all kinds of fields to 'autocomplete'
 * @todo: support for checkboxes
 * @todo: support for comboboxes
 * @todo: support for ...
 */

function multicomplete_menu() {
  $items = array();

  $items['multicomplete/example'] = array(
    'title' => 'Example Multi Complete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multicomplete_example_form'),
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
  );

  $items['multicomplete/js/%/f/%'] = array(
    'title' => '',
    'page callback' => 'multicomplete_autocomplete',
    'page arguments' => array(2, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );



  return $items;
}

function multicomplete_example_form($form, &$form_state) {
  $form = array();
  $form['example_block']['f_first_field'] = array(
    '#title' => 'First Field',
    '#description' => '',
    '#type' => 'textfield',
    '#autocomplete_path' => 'multicomplete/js/multicomplete_example_form_multicomplete_objects/f/first_field',
    '#attributes' => array(
      'class' => array('multicomplete'), //@todo: workaround this. probably figure out how to use form_render_thingies
    ),
  );
  $form['example_block']['f_second_field'] = array(
    '#title' => 'Second Field',
    '#type' => 'textfield',
  );
  $form['example_block']['test_detecting_multicomplete']['third_field'] = array(
    '#title' => 'Third Field',
    '#type' => 'textfield',
  );
  return $form;
}

function multicomplete_example_form_multicomplete_objects($string, $key_field) {
  return array(
    array(
      'first_field' => 'First field value 1',
      'second_field' => 'Second field value 1',
      'third_field' => 'Third field value 1',
    ),
    array(
      'first_field' => 'First field value 2',
      'second_field' => 'Second field value 2',
      'third_field' => 'Third field value 2',
    ),
    array(
      'first_field' => 'First field value 3',
      'second_field' => 'Second field value 3',
      'third_field' => 'Third field value 3',
    ),
    array(
      'first_field' => 'First field value 4',
      'second_field' => 'Second field value 4',
      'third_field' => 'Third field value 4',
    ),
  );
}

function multicomplete_example_form_multicomplete_objects_info($key_field, $identifier, &$definition) {
  $definition['#type'] = 'default'; //type to get data
  $definition['#map'] = array(// map data field to form fields.
    'first_field' => 'f_first_field',
    'second_field' => 'f_second_field',
    'third_field'
  );
}

function multicomplete_example_form_multicomplete_objects_first_field_info($key_field, $identifier, &$definition) {
  // not implemented 
}

/**
 * @todo Document the multicomplete autocomplete function with all hooks etc etc.
 * @param type $string
 * @param type $identifier
 * @param type $key_field 
 */
function multicomplete_autocomplete($identifier, $key_field, $string) {
  $definition = array(); // initialize definition and defaults.
  $definition['#arguments'] = array('string' => $string, 'identifier' => $identifier, 'key_field' => $key_field);
  $definition['#identifier'] = $identifier;
  $definition['#key'] = $key_field;
  $definition['#type'] = 'default';
  $definition['#map'] = array($key_field);
  $definition['#do_blanking'] = TRUE; // with blanking enabled, we will include empty values so their fields will be made empty on autocompleting too.


  $info_callback = $identifier . '_info';
  $info_field_callback = $identifier . '_' . $key_field . '_info';

  if (function_exists($info_callback)) {
    call_user_func_array($info_callback, array($key_field, $identifier, &$definition));
    $definition['#info_callbacks'][] = $info_callback;
  }
  if (function_exists($info_field_callback)) {
    call_user_func_array($info_field_callback, array($key_field, $identifier, &$definition));
    $definition['#info_callbacks'][] = $info_field_callback;
  }



  $data_callback = 'multicomplete_type_' . $definition['#type'] . '_data';
  if (!function_exists($data_callback)) {
    $err_elements = array(
      'message' => array('#type' => 'markup', '#markup' => 'Given multicomplete type is not known to the system.'),
      'funcs' => array('#type' => 'markup', '#markup' => sprintf('<p>Function %s does not exist. </p>', $object_callback, $string, $key_field)),
    );
    watchdog('error', drupal_render($err_elements));
    return drupal_json_output(array());
  }


  $data = call_user_func_array($data_callback, array($string, &$definition));
  if (!is_array($data)) {
    $err_elements = array(
      'message' => array('#type' => 'markup', '#markup' => 'Multicomplete default data callback did not return a proper value.'),
      'funcs' => array('#type' => 'markup', '#markup' => sprintf('<p>Function call: %s("%s", "%s") </p>', $identifier, $string, $definition)),
      'return' => array('#type' => 'markup', '#markup' => sprintf('Return value: <br/><pre>%s</pre>'), (string) $data),
    );
    watchdog('error', drupal_render($err_elements));
    return drupal_json_output(array());
  }


  $pre_render = multicomplete_prepare_render($data, $definition);

  //@todo run pre render through render and add render to each field.


  return drupal_json_output($pre_render);
}

/**
 * @todo: Document the default data type 
 * @param type $string
 * @param type $definition
 * @return type 
 */
function multicomplete_type_default_data($string, &$definition) {
  $identifier = $definition['#identifier'];
  return call_user_func_array($identifier, array($string, &$definition));
}

/**
 * @todo: Document prepare render function.
 * @param type $data
 * @param type $definition
 * @param type $key_field
 * @return array 
 */
function multicomplete_prepare_render(&$data, &$definition) {

  $maps = array();

  foreach ($definition['#map'] as $data_field => $form_field) {
    if (is_int($data_field)) {
      $maps[$form_field] = $form_field;
    }
    else {
      $maps[$data_field] = $form_field;
    }
  }
  $definition['#map'] = $maps;

  //@todo: implement allowing other modules to alter the object list.

  $render_arr = array();
  foreach ($data as $obj) {
    $value = (array) $obj;
    $key_value = $value[$definition['#key']];

    $fields = array();
    $fields['#prefix'] = '<span style="visibility: hidden;" class="multicomplete-field-definition">';
    $fields['#suffix'] = '<span>';

    foreach (array_keys($value) as $obj_field) {
      $field = array();
      $field['#type'] = 'markup';


      //$field = array('#theme' => 'multicomplete_field_item');
      //$field['#attributes']['class'][] = 'multicomplete-field-value';

      if (array_key_exists($obj_field, $maps)) {
        $form_field = $maps[$obj_field];
      }
      else {
        $form_field = $obj_field;
      }
      $field['#markup'] = check_plain($value[$obj_field]);
      $field['#prefix'] = '<span class="multicomplete-field-value" field="' . $form_field . '">';
      $field['#suffix'] = '</span>';

      $fields[$obj_field] = $field;
    }

    $render_arr[$key_value] = drupal_render($fields);
  }

  //@todo: implement allowing other modules to alter render array.
  return $render_arr;
  //return array('definition' => $definition, 'render_arr' => $render_arr);
}

function multicomplete_prepare_render_items($object, $ret_value, $key_field) {
  //@todo: render stuff I suppose.. (It's getting kinda late)
}

