<?php

/* global todo list
 *
 * support for all kinds of fields to 'autocomplete'
 * @todo: support for checkboxes
 * @todo: support for comboboxes
 * @todo: support for ...
 */

function multicomplete_menu() {
  $items = array();

  $items['multicomplete/example'] = array(
    'title' => 'Example Multi Complete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multicomplete_example_form'),
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
  );

  $items['multicomplete/js/%/f/%'] = array(
    'title' => '',
    'page callback' => 'multicomplete_autocomplete',
    'page arguments' => array(2, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function multicomplete_theme() {
  $items = array(
    'multicomplete_definition' => array(
      'render element' => 'element',
    ),
    'multicomplete_default_element' => array(
      'render element' => 'element',
    ),
    'multicomplete_render_multicomplete_value' => array(
      'render element' => 'element',
    ),
  );
  return $items;
}

function multicomplete_example_form($form, &$form_state) {
  $form = array();
  $form['example_block']['f_first_field'] = array(
    '#title' => 'First Field',
    '#description' => '',
    '#type' => 'textfield',
    '#autocomplete_path' => 'multicomplete/js/multicomplete_example_form_multicomplete_objects/f/first_field',
    '#attributes' => array(
      'class' => array('multicomplete'), //@todo: workaround this. probably figure out how to use form_render_thingies
    ),
  );
  $form['example_block']['f_second_field'] = array(
    '#title' => 'Second Field',
    '#type' => 'textfield',
  );
  $form['example_block']['test_detecting_multicomplete']['third_field'] = array(
    '#title' => 'Third Field',
    '#type' => 'textfield',
  );
  return $form;
}

function multicomplete_example_form_multicomplete_objects($string, $key_field) {
  return array(
    array(
      'first_field' => 'First field value 1',
      'second_field' => 'Second field value 1',
      'third_field' => TRUE,
      'strict_test' => 'test',
    ),
    array(
      'first_field' => 'First field value 2',
      'second_field' => 'Second field value 2',
      'third_field' => FALSE,
      'strict_test' => 'test',
    ),
    array(
      'first_field' => 'First field value 3',
      'second_field' => 'Second field value 3',
      'third_field' => FALSE,
      'strict_test' => 'test',
    ),
    array(
      'first_field' => 'First field value 4',
      'second_field' => 'Second field value 4',
      'third_field' => TRUE,
      'strict_test' => 'test',
    ),
  );
}

function multicomplete_example_form_multicomplete_objects_info($key_field, $identifier, &$definition) {
  $definition['#type'] = 'default'; //type to get data
  $definition['#fields'] = array(// map data field to form fields.
    'first_field' => 'f_first_field',
    'second_field' => array('f_second_field'),
    'third_field'
  );
}

function multicomplete_example_form_multicomplete_objects_first_field_info($key_field, $identifier, &$definition) {
  // not implemented
}

/**
 *
 * @param $string
 *
 * @param $definition
 *
 * @return
 *
 * @todo: Document the default data type
 */
function multicomplete_type_default_data($string, &$definition) {
  $identifier = $definition['#identifier'];
  return call_user_func_array($identifier, array($string, &$definition));
}

/**
 *
 * @param $string
 *
 * @param $identifier
 *
 * @param $key_field
 *
 * @return
 *
 * @todo Document the multicomplete autocomplete function with all hooks etc etc.
 * @todo Document different hooks we provide / call
 * @todo Document $definition options
 */
function multicomplete_autocomplete($identifier, $key_field, $string) {
  $definition = array(); // initialize definition and defaults.
  $definition['#string'] = $string;
  $definition['#identifier'] = $identifier;
  $definition['#key'] = $key_field;
  $definition['#type'] = 'default';
  $definition['#fields'] = array($key_field);
  $definition['#strict'] = FALSE;

  $info_callback = $identifier . '_info';
  $info_field_callback = $identifier . '_' . $key_field . '_info';

  if (function_exists($info_callback)) {
    call_user_func_array($info_callback, array($key_field, $identifier, &$definition));
    $definition['#info_callbacks'][] = $info_callback;
  }
  if (function_exists($info_field_callback)) {
    call_user_func_array($info_field_callback, array($key_field, $identifier, &$definition));
    $definition['#info_callbacks'][] = $info_field_callback;
  }

  //<editor-fold defaultstate="collapsed" desc=" Data retrieval stuff ">
  $data_callback = 'multicomplete_type_' . $definition['#type'] . '_data';
  if (!function_exists($data_callback)) {
    $err_elements = array(
      'message' => array('#type' => 'markup', '#markup' => 'Given multicomplete type is not known to the system.'),
      'funcs' => array('#type' => 'markup', '#markup' => sprintf('<p>Function %s does not exist. </p>', $data_callback)),
    );
    watchdog('error', drupal_render($err_elements));
    return drupal_json_output(array());
  }

  $data = call_user_func_array($data_callback, array($string, &$definition));
  if (!is_array($data)) {
    $err_elements = array(
      'message' => array('#type' => 'markup', '#markup' => 'Multicomplete default data callback did not return a proper value.'),
      'funcs' => array('#type' => 'markup', '#markup' => sprintf('<p>Function call: %s("%s", "%s") </p>', $identifier, $string, $definition)),
      'return' => array('#type' => 'markup', '#markup' => sprintf('Return value: <br/><pre>%s</pre>'), (string) $data),
    );
    watchdog('error', drupal_render($err_elements));
    return drupal_json_output(array());
  }

  //@todo: implement allowing other modules to alter the object list.
  //</editor-fold>
  // Cleanup mappings.
  _multicomplete_process_fields($definition);

  $pre_render = multicomplete_prepare_render($data, $definition);
  //@todo: Allow other modules to adjust the prepared render array.

  $render = _multicomplete_render($pre_render, $definition);

  return drupal_json_output($render);
}

// Preprocess fields and create the map (object field to form field)
function _multicomplete_process_fields(&$definition) {
  $maps = array();

  foreach ($definition['#fields'] as $data_field => &$form_field) {

    $field_name = is_array($form_field) ? array_shift($form_field) : $form_field;
    $key_name = is_int($data_field) ? $field_name : $data_field;

    $maps[$key_name] = $field_name;
    $definition['#fields'][$key_name] = is_array($form_field) ? $form_field : array();
    if (is_int($data_field)) {
      unset($definition['#fields'][$data_field]);
    }
  }
  $definition['#map'] = $maps;
}

/**
 *
 * @param $data
 *
 * @param $definition
 *
 * @param $key_field
 *
 * @return
 *
 * @todo: Document prepare render function.
 */
function multicomplete_prepare_render(&$data, &$definition) {
  $maps = $definition['#map'];
  $render_arr = array();
  foreach ($data as $obj) {
    $value = (array) $obj;
    $key_value = $value[$definition['#key']];

    $fields = array();
    $fields['#theme'] = array('multicomplete_definition');
    $fields['#definition'] = $definition;
    $fields['values'] = array();

    foreach (array_keys($value) as $obj_field) {

      $field = (isset($definition['#fields'][$obj_field]) && !$definition['#strict']) ? $definition['#fields'][$obj_field] : array();
      if (!isset($field['#type'])) {
        $field['#type'] = 'text';
      }

      if (array_key_exists($obj_field, $maps)) {
        $form_field = $maps[$obj_field];
      }
      elseif (!$definition['#strict']) {
        $form_field = $obj_field;
      }
      else {
        continue;
      }

      $field['#value'] = check_plain((string) $value[$obj_field]);

      if (is_bool($value[$obj_field])) {
        $field['#value'] = $value[$obj_field] ? '1' : '0';
        $field['#type'] = 'boolean';
      }

      $fields['values'][$form_field] = $field;
    }

    $format_callback = isset($definition['#element_format']) ? $definition['#element_format'] : 'multicomplete_render_element_format';
    if (!function_exists($format_callback)) {
      $err_elements = array(
        'message' => array('#type' => 'markup', '#markup' => 'Given multicomplete element formatter is not known to the system.'),
        'funcs' => array('#type' => 'markup', '#markup' => sprintf('<p>Function %s does not exist. </p>', $format_callback)),
      );
      watchdog('error', drupal_render($err_elements));
      return array();
    }
    $fields['format'] = call_user_func_array($format_callback, array(&$obj, &$fields['values'], &$definition));

    //@todo implement running the #element_format definition to prepare the format array.
    //@todo: Allow altering / hooking into this.

    $render_arr[$key_value] = $fields;
  }

  return $render_arr;
  //return array('definition' => $definition, 'render_arr' => $render_arr);
}

function _multicomplete_render($render, &$definition) {
  $rendered = array();
  foreach (array_keys($render) as $key) {
    $rendered[$key] = drupal_render($render[$key]);
  }
  return $rendered;
}

/**
 *
 * @param $variables
 *
 * @return
 *
 * @todo: Document de default multicomplete_definition theme.
 */
function theme_multicomplete_definition($variables) {
  //@todo implement proper rendering.
  $element = $variables['element'];
  $values = $element['values'];
  $format = $element['format'];
  $definition = $element['#definition'];
  $output = '';
  //$attributes = $variables['attributes'];

  $output .= '<div' /* . drupal_attributes($attributes) */ . '>';
  $output .= '<span style="display: none" class="multicomplete-element">' . _multicomplete_render_fields($values, $definition) . '</span>';
  $output .= drupal_render($format);
  $output .= '</div>';
  return $output;
}

// Here we render the important field definitions to (ab)use in javascript land.
function _multicomplete_render_fields($values, $definition) {
  $output = '';
  foreach ($values as $key => $val) {
    $output .= '<span';
    $attributes = array(
      'data-field' => $key,
      'data-type' => $val['#type']
    );

    $output .= drupal_attributes($attributes);
    $output .= '>';
    $output .= $val['#value'];
    $output .= '</span>';
  }
  return $output;
}

/**
 *
 * @param $obj
 *
 * @param $values
 *
 * @param $definition
 *
 * @return
 *
 * @todo: document default render_element_format function
 */
function multicomplete_render_element_format(&$obj, &$values, &$definition) {
  return array(
    '#theme' => 'multicomplete_default_element',
    'object' => $obj,
    'definition' => $definition,
    'values' => $values,
  );
}

/**
 *
 * @param $variables
 *
 * @return
 *
 * @todo: document default multicomplete element render function. used by the render_element_format.
 */
function theme_multicomplete_default_element($variables) {
  $element = $variables['element'];
  $object = $element['object'];
  $definition = $element['definition'];
  $values = $element['values'];
  $output = '';
  $value_arr = array();

  foreach ($values as $val) {

    if (!isset($val['#hidden']) || $val['#hidden'] == FALSE) {

      switch ($val['#type']) {
        case 'text':
          $value_arr[] = $val['#value'];
          break;
        case 'boolean':
          break;
        default:
          $value_arr[] = (string) $val['#value'];
      }
    }
  }

  $output .= implode(', ', $value_arr);

  return $output;
}